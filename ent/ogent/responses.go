// Code generated by entc, DO NOT EDIT.

package ogent

import "t/ent"

func NewTodoCreate(e *ent.Todo) *TodoCreate {
	if e == nil {
		return nil
	}
	return &TodoCreate{
		ID:    e.ID,
		Title: e.Title,
		Done:  NewOptBool(e.Done),
	}
}

func NewTodoCreates(es []*ent.Todo) []TodoCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]TodoCreate, len(es))
	for i, e := range es {
		r[i] = NewTodoCreate(e).Elem()
	}
	return r
}

func (t *TodoCreate) Elem() TodoCreate {
	if t != nil {
		return TodoCreate{}
	}
	return *t
}

func NewTodoList(e *ent.Todo) *TodoList {
	if e == nil {
		return nil
	}
	return &TodoList{
		ID:    e.ID,
		Title: e.Title,
		Done:  NewOptBool(e.Done),
	}
}

func NewTodoLists(es []*ent.Todo) []TodoList {
	if len(es) == 0 {
		return nil
	}
	r := make([]TodoList, len(es))
	for i, e := range es {
		r[i] = NewTodoList(e).Elem()
	}
	return r
}

func (t *TodoList) Elem() TodoList {
	if t != nil {
		return TodoList{}
	}
	return *t
}

func NewTodoRead(e *ent.Todo) *TodoRead {
	if e == nil {
		return nil
	}
	return &TodoRead{
		ID:    e.ID,
		Title: e.Title,
		Done:  NewOptBool(e.Done),
	}
}

func NewTodoReads(es []*ent.Todo) []TodoRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]TodoRead, len(es))
	for i, e := range es {
		r[i] = NewTodoRead(e).Elem()
	}
	return r
}

func (t *TodoRead) Elem() TodoRead {
	if t != nil {
		return TodoRead{}
	}
	return *t
}

func NewTodoUpdate(e *ent.Todo) *TodoUpdate {
	if e == nil {
		return nil
	}
	return &TodoUpdate{
		ID:    e.ID,
		Title: e.Title,
		Done:  NewOptBool(e.Done),
	}
}

func NewTodoUpdates(es []*ent.Todo) []TodoUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]TodoUpdate, len(es))
	for i, e := range es {
		r[i] = NewTodoUpdate(e).Elem()
	}
	return r
}

func (t *TodoUpdate) Elem() TodoUpdate {
	if t != nil {
		return TodoUpdate{}
	}
	return *t
}

func NewUsersCreate(e *ent.Users) *UsersCreate {
	if e == nil {
		return nil
	}
	return &UsersCreate{
		ID:        e.ID,
		User:      e.User,
		First:     NewOptInt(e.First),
		Start:     NewOptBool(e.Start),
		Draw:      NewOptInt(e.Draw),
		CreatedAt: NewOptDateTime(e.CreatedAt),
		UpdatedAt: NewOptDateTime(e.UpdatedAt),
	}
}

func NewUsersCreates(es []*ent.Users) []UsersCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UsersCreate, len(es))
	for i, e := range es {
		r[i] = NewUsersCreate(e).Elem()
	}
	return r
}

func (u *UsersCreate) Elem() UsersCreate {
	if u != nil {
		return UsersCreate{}
	}
	return *u
}

func NewUsersList(e *ent.Users) *UsersList {
	if e == nil {
		return nil
	}
	return &UsersList{
		ID:        e.ID,
		User:      e.User,
		First:     NewOptInt(e.First),
		Start:     NewOptBool(e.Start),
		Draw:      NewOptInt(e.Draw),
		CreatedAt: NewOptDateTime(e.CreatedAt),
		UpdatedAt: NewOptDateTime(e.UpdatedAt),
	}
}

func NewUsersLists(es []*ent.Users) []UsersList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UsersList, len(es))
	for i, e := range es {
		r[i] = NewUsersList(e).Elem()
	}
	return r
}

func (u *UsersList) Elem() UsersList {
	if u != nil {
		return UsersList{}
	}
	return *u
}

func NewUsersRead(e *ent.Users) *UsersRead {
	if e == nil {
		return nil
	}
	return &UsersRead{
		ID:        e.ID,
		User:      e.User,
		First:     NewOptInt(e.First),
		Start:     NewOptBool(e.Start),
		Draw:      NewOptInt(e.Draw),
		CreatedAt: NewOptDateTime(e.CreatedAt),
		UpdatedAt: NewOptDateTime(e.UpdatedAt),
	}
}

func NewUsersReads(es []*ent.Users) []UsersRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]UsersRead, len(es))
	for i, e := range es {
		r[i] = NewUsersRead(e).Elem()
	}
	return r
}

func (u *UsersRead) Elem() UsersRead {
	if u != nil {
		return UsersRead{}
	}
	return *u
}

func NewUsersUpdate(e *ent.Users) *UsersUpdate {
	if e == nil {
		return nil
	}
	return &UsersUpdate{
		ID:        e.ID,
		User:      e.User,
		First:     NewOptInt(e.First),
		Start:     NewOptBool(e.Start),
		Draw:      NewOptInt(e.Draw),
		CreatedAt: NewOptDateTime(e.CreatedAt),
		UpdatedAt: NewOptDateTime(e.UpdatedAt),
	}
}

func NewUsersUpdates(es []*ent.Users) []UsersUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UsersUpdate, len(es))
	for i, e := range es {
		r[i] = NewUsersUpdate(e).Elem()
	}
	return r
}

func (u *UsersUpdate) Elem() UsersUpdate {
	if u != nil {
		return UsersUpdate{}
	}
	return *u
}
